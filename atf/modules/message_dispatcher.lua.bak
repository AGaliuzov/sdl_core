local ph = require('protocol_handler')
local module = { mt = { __index = { } } }
local fbuffer_mt = { __index = { } }
local fstream_mt = { __index = { } }
function module.FileStorage(filename)
  local res = {}
  res.filename = filename
  res.wfd = io.open(filename, "w")
  res.rfd = io.open(filename, "r")
  setmetatable(res, fbuffer_mt)
  return res
end
function module.FileStream(filename, sessionId, service, chunksize)
  local res = {}
  res.filename = filename
  res.service = service
  res.sessionId = sessionId
  res.chunksize = chunksize or 1488
  res.protocol_handler = ph.ProtocolHandler()
  res.rfd = io.open(filename, "r")
  res.messageId = 1
  if res.rfd == nil then error("Cannot open file " .. filename) end
  setmetatable(res, fstream_mt)
  return res
end
function fbuffer_mt.__index:KeepMessage(msg)
  self.keep = msg
end
function fstream_mt.__index:KeepMessage(msg)
  self.keep = msg
end
function fbuffer_mt.__index:WriteMessage(msg)
  self.wfd:write(string.char(bit32.band(#msg, 0xff),
                            bit32.band(bit32.rshift(#msg, 8), 0xff),
                            bit32.band(bit32.rshift(#msg, 16), 0xff),
                            bit32.band(bit32.rshift(#msg, 24), 0xff)))
  self.wfd:write(msg)
end
function fbuffer_mt.__index:Flush()
  self.wfd:flush()
end
function fstream_mt.__index:GetMessage()
  print("DEBUG: fstream:Message")
  local data = self.rfd:read(self.chunksize)
  self.messageId = self.messageId + 1
  return table.concat(self.protocol_handler:Compose(
   {
     version = 2,
     encryption = 0,
     sessionId = self.sessionId,
     frameInfo = 0,
     frameType = 1,
     serviceType = self.service,
     binaryData = data,
     messageId = self.messageId
   }))
end
function fbuffer_mt.__index:GetMessage()
  print("DEBUG: fbuffer:Message")
  if self.keep then
    local res = self.keep
    self.keep = nil
    return res
  end
  local len = self.rfd:read(4)
  if len then
    len = bit32.lshift(string.byte(string.sub(len, 4, 4)), 24) +
          bit32.lshift(string.byte(string.sub(len, 3, 3)), 16) +
          bit32.lshift(string.byte(string.sub(len, 2, 2)), 8) +
          string.byte(string.sub(len, 1, 1))
    return self.rfd:read(len)
  end
end
function module.MessageDispatcher(connection)
  local res = {}
  res._d = qt.dynamic()
  res.generators = { }
  res.idx = 0
  res.connection = connection
  res.bufferSize = 8192
  res.mapped = { }
  function res._d:bytesWritten(c)
    print("DEBUG: bytesWritten: buffer size", res.bufferSize)
    if #res.generators == 0 then return end
    res.bufferSize = res.bufferSize + c
    for i = 1, #res.generators do
      if res.idx < #res.generators then
        res.idx = res.idx + 1
      else
        res.idx = 1
      end
      local msg = res.generators[res.idx]:GetMessage()
      if msg then
        if res.bufferSize > #msg then
          res.bufferSize = res.bufferSize - #msg
          res.connection:Send({ msg })
          break
        else
          res.generators[res.idx].KeepMessage(msg)
        end
      end
    end
  end
  qt.connect(res.connection.socket, "bytesWritten(qint64)", res._d, "bytesWritten(qint64)")
  setmetatable(res, module.mt)
  return res
end
function module.mt.__index:MapFile(filebuffer)
  self.mapped[filebuffer.filename] = filebuffer
  table.insert(self.generators, filebuffer)
  print("DEBUG: MapFile now", #self.generators)
end
function module.mt.__index:UnmapFile(filename)
  local fd = self.mapped[filename]
  table.insert(self.fds, fd)
end
function module.mt.__index:Pulse()
  self._d:bytesWritten(0)
end
return module
